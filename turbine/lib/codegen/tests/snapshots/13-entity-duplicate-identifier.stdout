localhost_3000/alice/entity/country.rs

use blockprotocol::{
    entity::Entity, EntityType, EntityTypeMut, EntityTypeRef, GenericEntityError,
    PropertyType as _, Type, TypeMut, TypeRef, VersionedUrlRef,
};
use error_stack::{Report, Result};
use hashbrown::HashMap;
use serde::Serialize;

use crate::localhost_3000::{
    alice::property::name::Name as Name0, bob::property::name::Name as Name1,
};
#[derive(Debug, Clone, Serialize)]
pub struct Properties {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name_0: Name0,
    #[serde(rename = "http://localhost:3000/@bob/types/property-type/name/")]
    pub name_1: Name1,
}
impl Properties {
    fn try_from_value(properties: HashMap<BaseUrl, Value>) -> Result<Self, GenericEntityError> {
        let name_0 = 'property: {
            let value = properties.remove("http://localhost:3000/@alice/types/property-type/name/");
            let Some (value) = value else { break 'property Err (Report :: new (GenericEntityError :: ExpectedProperty ("http://localhost:3000/@alice/types/property-type/name/"))) ; } ;
            let value = <Name0>::try_from_value(value).change_context(Report::new(
                GenericEntityError::Property(
                    "http://localhost:3000/@alice/types/property-type/name/",
                ),
            ));
            value
        };
        let name_1 = 'property: {
            let value = properties.remove("http://localhost:3000/@bob/types/property-type/name/");
            let Some (value) = value else { break 'property Err (Report :: new (GenericEntityError :: ExpectedProperty ("http://localhost:3000/@bob/types/property-type/name/"))) ; } ;
            let value = <Name1>::try_from_value(value).change_context(Report::new(
                GenericEntityError::Property(
                    "http://localhost:3000/@bob/types/property-type/name/",
                ),
            ));
            value
        };
        let __report0 = blockprotocol::fold_tuple_reports((name_0, name_1));
        let ((name_0, name_1),) = blockprotocol::fold_tuple_reports((__report0,))?;
        let this = Self { name_0, name_1 };
        Ok(this)
    }
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Country {
    pub properties: Properties,
}
pub type CountryV1 = Country;
impl Type for Country {
    type Mut < 'a > = CountryMut < 'a > where Self : 'a ;
    type Ref < 'a > = CountryRef < 'a > where Self : 'a ;

    const ID: VersionedUrlRef<'static> =
        url!("http://localhost:3000/@alice/types/entity-type/country/" / v / 1u32);

    fn as_ref(&self) -> Self::Ref<'_> {
        todo!()
    }

    fn as_mut(&mut self) -> Self::Mut<'_> {
        todo!()
    }
}
impl EntityType for Country {
    type Error = GenericEntityError;

    fn try_from_entity(value: Entity) -> Option<Result<Self, Self::Error>> {
        if Self::ID == *value.id() {
            return None;
        }
        let properties = Properties::try_from_value(value.properties.0);
        let (properties,) = blockprotocol::fold_tuple_reports((properties,))?;
        let this = Self { properties };
        Ok(this)
    }
}
#[derive(Debug, Clone, Serialize)]
pub struct PropertiesRef<'a> {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name_0: Name0::Ref<'a>,
    #[serde(rename = "http://localhost:3000/@bob/types/property-type/name/")]
    pub name_1: Name1::Ref<'a>,
}
impl PropertiesRef<'a> {
    fn try_from_value(properties: &'a HashMap<BaseUrl, Value>) -> Result<Self, GenericEntityError> {
        let name_0 = 'property: {
            let value = properties.get("http://localhost:3000/@alice/types/property-type/name/");
            let Some (value) = value else { break 'property Err (Report :: new (GenericEntityError :: ExpectedProperty ("http://localhost:3000/@alice/types/property-type/name/"))) ; } ;
            let value = <Name0>::try_from_value(value).change_context(Report::new(
                GenericEntityError::Property(
                    "http://localhost:3000/@alice/types/property-type/name/",
                ),
            ));
            value
        };
        let name_1 = 'property: {
            let value = properties.get("http://localhost:3000/@bob/types/property-type/name/");
            let Some (value) = value else { break 'property Err (Report :: new (GenericEntityError :: ExpectedProperty ("http://localhost:3000/@bob/types/property-type/name/"))) ; } ;
            let value = <Name1>::try_from_value(value).change_context(Report::new(
                GenericEntityError::Property(
                    "http://localhost:3000/@bob/types/property-type/name/",
                ),
            ));
            value
        };
        let __report0 = blockprotocol::fold_tuple_reports((name_0, name_1));
        let ((name_0, name_1),) = blockprotocol::fold_tuple_reports((__report0,))?;
        let this = Self { name_0, name_1 };
        Ok(this)
    }
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CountryRef<'a> {
    pub properties: PropertiesRef<'a>,
}
pub type CountryV1Ref<'a> = CountryRef<'a>;
impl TypeRef for CountryRef<'_> {
    type Owned = Country;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeRef<'a> for CountryRef<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
#[derive(Debug, Clone, Serialize)]
pub struct PropertiesMut<'a> {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name_0: Name0::Mut<'a>,
    #[serde(rename = "http://localhost:3000/@bob/types/property-type/name/")]
    pub name_1: Name1::Mut<'a>,
}
impl PropertiesMut<'a> {
    fn try_from_value(
        properties: &'a mut HashMap<BaseUrl, Value>,
    ) -> Result<Self, GenericEntityError> {
        let name_0 = 'property: {
            let value = unsafe {
                let value =
                    properties.get_mut("http://localhost:3000/@alice/types/property-type/name/");
                let value = value.map(|value| value as *mut _);
                &mut *value
            };
            let Some (value) = value else { break 'property Err (Report :: new (GenericEntityError :: ExpectedProperty ("http://localhost:3000/@alice/types/property-type/name/"))) ; } ;
            let value = <Name0>::try_from_value(value).change_context(Report::new(
                GenericEntityError::Property(
                    "http://localhost:3000/@alice/types/property-type/name/",
                ),
            ));
            value
        };
        let name_1 = 'property: {
            let value = unsafe {
                let value =
                    properties.get_mut("http://localhost:3000/@bob/types/property-type/name/");
                let value = value.map(|value| value as *mut _);
                &mut *value
            };
            let Some (value) = value else { break 'property Err (Report :: new (GenericEntityError :: ExpectedProperty ("http://localhost:3000/@bob/types/property-type/name/"))) ; } ;
            let value = <Name1>::try_from_value(value).change_context(Report::new(
                GenericEntityError::Property(
                    "http://localhost:3000/@bob/types/property-type/name/",
                ),
            ));
            value
        };
        let __report0 = blockprotocol::fold_tuple_reports((name_0, name_1));
        let ((name_0, name_1),) = blockprotocol::fold_tuple_reports((__report0,))?;
        let this = Self { name_0, name_1 };
        Ok(this)
    }
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CountryMut<'a> {
    pub properties: PropertiesMut<'a>,
}
pub type CountryV1Mut<'a> = CountryMut<'a>;
impl TypeMut for CountryMut<'_> {
    type Owned = Country;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeMut<'a> for CountryMut<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a mut Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}


---

localhost_3000/alice/property/name.rs

use blockprotocol::{
    types::data::Text, DataType as _, GenericEntityError, PropertyType, PropertyTypeMut,
    PropertyTypeRef, Type, TypeMut, TypeRef, VersionedUrlRef,
};
use error_stack::Result;
use serde::Serialize;
#[derive(Debug, Clone, Serialize)]
pub struct Name(pub Text);
impl Type for Name {
    type Mut < 'a > = NameMut < 'a > where Self : 'a ;
    type Ref < 'a > = NameRef < 'a > where Self : 'a ;

    fn as_mut(&mut self) -> Self::Mut<'_> {
        todo!()
    }

    fn as_ref(&self) -> Self::Ref<'_> {
        todo!()
    }
}
impl PropertyType for Name {
    type Error = GenericPropertyError;

    fn try_from_value(value: serde_json::Value) -> Result<Self, Self::Error> {
        todo!()
    }
}
pub type NameV1<'a> = Name<'a>;
#[derive(Debug, Clone, Serialize)]
pub struct NameRef<'a>(pub Text::Ref<'a>);
impl TypeRef for NameRef<'_> {
    type Owned = Name;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> PropertyTypeRef<'a> for NameRef<'a> {
    type Error = GenericPropertyError;

    fn try_from_value(value: &'a serde_json::Value) -> Result<Self, Self::Error> {
        todo!()
    }
}
pub type NameV1Ref<'a> = NameRef<'a>;
#[derive(Debug, Serialize)]
pub struct NameMut<'a>(pub Text::Mut<'a>);
impl TypeMut for NameMut<'_> {
    type Owned = Name;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> PropertyTypeMut<'a> for NameMut<'a> {
    type Error = GenericPropertyError;

    fn try_from_value(value: &'a mut serde_json::Value) -> Result<Self, Self::Error> {
        todo!()
    }
}
pub type NameV1Mut<'a> = NameMut<'a>;


---

localhost_3000/bob/property/name.rs

use blockprotocol::{
    types::data::Text, DataType as _, GenericEntityError, PropertyType, PropertyTypeMut,
    PropertyTypeRef, Type, TypeMut, TypeRef, VersionedUrlRef,
};
use error_stack::Result;
use serde::Serialize;
#[derive(Debug, Clone, Serialize)]
pub struct Name(pub Text);
impl Type for Name {
    type Mut < 'a > = NameMut < 'a > where Self : 'a ;
    type Ref < 'a > = NameRef < 'a > where Self : 'a ;

    fn as_mut(&mut self) -> Self::Mut<'_> {
        todo!()
    }

    fn as_ref(&self) -> Self::Ref<'_> {
        todo!()
    }
}
impl PropertyType for Name {
    type Error = GenericPropertyError;

    fn try_from_value(value: serde_json::Value) -> Result<Self, Self::Error> {
        todo!()
    }
}
pub type NameV1<'a> = Name<'a>;
#[derive(Debug, Clone, Serialize)]
pub struct NameRef<'a>(pub Text::Ref<'a>);
impl TypeRef for NameRef<'_> {
    type Owned = Name;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> PropertyTypeRef<'a> for NameRef<'a> {
    type Error = GenericPropertyError;

    fn try_from_value(value: &'a serde_json::Value) -> Result<Self, Self::Error> {
        todo!()
    }
}
pub type NameV1Ref<'a> = NameRef<'a>;
#[derive(Debug, Serialize)]
pub struct NameMut<'a>(pub Text::Mut<'a>);
impl TypeMut for NameMut<'_> {
    type Owned = Name;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> PropertyTypeMut<'a> for NameMut<'a> {
    type Error = GenericPropertyError;

    fn try_from_value(value: &'a mut serde_json::Value) -> Result<Self, Self::Error> {
        todo!()
    }
}
pub type NameV1Mut<'a> = NameMut<'a>;
