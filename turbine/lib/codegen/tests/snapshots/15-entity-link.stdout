localhost_3000/alice/entity/part_of.rs

use blockprotocol::{
    entity::{Entity, LinkData},
    EntityType, EntityTypeMut, EntityTypeRef, GenericEntityError, PropertyType as _, Type, TypeMut,
    TypeRef, VersionedUrlRef,
};
use error_stack::{Report, Result};
use hashbrown::HashMap;
use serde::Serialize;
#[derive(Debug, Clone, Serialize)]
pub struct Properties {}
impl Properties {
    fn try_from_value(properties: HashMap<BaseUrl, Value>) -> Result<Self, GenericEntityError> {
        todo!()
    }
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PartOf {
    pub properties: Properties,
    pub link_data: LinkData,
}
pub type PartOfV1 = PartOf;
impl Type for PartOf {
    type Mut < 'a > = PartOfMut < 'a > where Self : 'a ;
    type Ref < 'a > = PartOfRef < 'a > where Self : 'a ;

    const ID: VersionedUrlRef<'static> =
        url!("http://localhost:3000/@alice/types/entity-type/partOf/" / v / 1u32);

    fn as_ref(&self) -> Self::Ref<'_> {
        todo!()
    }

    fn as_mut(&self) -> Self::Mut<'_> {
        todo!()
    }
}
impl EntityType for PartOf {
    type Error = GenericEntityError;

    fn try_from_entity(value: Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
#[derive(Debug, Clone, Serialize)]
pub struct PropertiesRef<'a> {}
impl PropertiesRef<'a> {
    fn try_from_value(properties: &'a HashMap<BaseUrl, Value>) -> Result<Self, GenericEntityError> {
        todo!()
    }
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PartOfRef<'a> {
    pub properties: PropertiesRef<'a>,
    pub link_data: &'a LinkData,
}
pub type PartOfV1Ref<'a> = PartOfRef<'a>;
impl TypeRef for PartOfRef<'_> {
    type Owned = PartOf;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeRef<'a> for PartOfRef<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
#[derive(Debug, Clone, Serialize)]
pub struct PropertiesMut<'a> {}
impl PropertiesMut<'a> {
    fn try_from_value(
        properties: &'a mut HashMap<BaseUrl, Value>,
    ) -> Result<Self, GenericEntityError> {
        todo!()
    }
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PartOfMut<'a> {
    pub properties: PropertiesMut<'a>,
    pub link_data: &'a mut LinkData,
}
pub type PartOfV1Mut<'a> = PartOfMut<'a>;
impl TypeMut for PartOfMut<'_> {
    type Owned = PartOf;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeMut<'a> for PartOfMut<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a mut Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
