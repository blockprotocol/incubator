localhost_3000/alice/entity/country/mod.rs

use blockprotocol::{
    entity::Entity, EntityType, EntityTypeMut, EntityTypeRef, GenericEntityError,
    PropertyType as _, Type, TypeMut, TypeRef, VersionedUrlRef,
};
use error_stack::Result;
use serde::Serialize;

use crate::localhost_3000::alice::property::{country_code::CountryCode, name::Name};
#[derive(Debug, Clone, Serialize)]
pub struct Properties {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/countryCode/")]
    pub country_code: CountryCode,
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name: Name,
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Country {
    pub properties: Properties,
}
impl Type for Country {
    type Mut < 'a > = CountryMut < 'a > where Self : 'a ;
    type Ref < 'a > = CountryRef < 'a > where Self : 'a ;

    const ID: VersionedUrlRef<'static> =
        url!("http://localhost:3000/@alice/types/entity-type/country/" / v / 2u32);

    fn as_ref(&self) -> Self::Ref<'_> {
        todo!()
    }

    fn as_mut(&self) -> Self::Mut<'_> {
        todo!()
    }
}
impl EntityType for Country {
    type Error = GenericEntityError;

    fn try_from_entity(value: Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
pub type CountryV2 = Country;
pub struct PropertiesRef<'a> {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/countryCode/")]
    pub country_code: CountryCode::Ref<'a>,
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name: Name::Ref<'a>,
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CountryRef<'a> {
    pub properties: PropertiesRef<'a>,
}
impl TypeRef for CountryRef<'_> {
    type Owned = Country;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeRef<'a> for CountryRef<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
pub type CountryV2Ref<'a> = CountryRef<'a>;
pub struct PropertiesMut<'a> {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/countryCode/")]
    pub country_code: CountryCode::Mut<'a>,
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name: Name::Mut<'a>,
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CountryMut<'a> {
    pub properties: PropertiesMut<'a>,
}
impl TypeMut for CountryMut<'_> {
    type Owned = Country;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeMut<'a> for CountryMut<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a mut Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
pub type CountryV2Mut<'a> = CountryMut<'a>;
pub mod v1;
pub use v1::CountryV1;


---

localhost_3000/alice/entity/country/v1.rs

use blockprotocol::{
    entity::Entity, EntityType, EntityTypeMut, EntityTypeRef, GenericEntityError,
    PropertyType as _, Type, TypeMut, TypeRef, VersionedUrlRef,
};
use error_stack::Result;
use serde::Serialize;

use crate::localhost_3000::alice::property::name::Name;
#[derive(Debug, Clone, Serialize)]
pub struct Properties {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name: Name,
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CountryV1 {
    pub properties: Properties,
}
impl Type for CountryV1 {
    type Mut < 'a > = CountryV1Mut < 'a > where Self : 'a ;
    type Ref < 'a > = CountryV1Ref < 'a > where Self : 'a ;

    const ID: VersionedUrlRef<'static> =
        url!("http://localhost:3000/@alice/types/entity-type/country/" / v / 1u32);

    fn as_ref(&self) -> Self::Ref<'_> {
        todo!()
    }

    fn as_mut(&self) -> Self::Mut<'_> {
        todo!()
    }
}
impl EntityType for CountryV1 {
    type Error = GenericEntityError;

    fn try_from_entity(value: Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
pub struct PropertiesRef<'a> {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name: Name::Ref<'a>,
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CountryV1Ref<'a> {
    pub properties: PropertiesRef<'a>,
}
impl TypeRef for CountryV1Ref<'_> {
    type Owned = CountryV1;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeRef<'a> for CountryV1Ref<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}
pub struct PropertiesMut<'a> {
    #[serde(rename = "http://localhost:3000/@alice/types/property-type/name/")]
    pub name: Name::Mut<'a>,
}
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CountryV1Mut<'a> {
    pub properties: PropertiesMut<'a>,
}
impl TypeMut for CountryV1Mut<'_> {
    type Owned = CountryV1;

    fn into_owned(self) -> Self::Owned {
        todo!();
    }
}
impl<'a> EntityTypeMut<'a> for CountryV1Mut<'a> {
    type Error = GenericEntityError;

    fn try_from_entity(value: &'a mut Entity) -> Option<Result<Self, Self::Error>> {
        todo!()
    }
}


---

localhost_3000/alice/property/country_code.rs

pub struct CountryCode(pub Text);
pub struct CountryCodeRef<'a>(pub Text::Ref<'a>);
pub struct CountryCodeMut<'a>(pub Text::Mut<'a>);


---

localhost_3000/alice/property/name.rs

pub struct Name(pub Text);
pub struct NameRef<'a>(pub Text::Ref<'a>);
pub struct NameMut<'a>(pub Text::Mut<'a>);
